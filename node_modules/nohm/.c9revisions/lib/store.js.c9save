{"ts":1390631183882,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n};\n\nvar async = require('async');\nvar h = require(__dirname + '/helpers');\nvar crypto = require('crypto');\n\n/**\n *  Saves the object by either creating, or updating it.\n */\nexports.save = function save(options) {\n\n  var callback = h.getCallback(arguments);\n  \n  options = h.$extend({\n    silent: false,\n    continue_on_link_error: false\n  }, options);\n\n  var self = this,\n    id_tries = 0,\n    action = 'create';\n\n  var generateId = function () {\n    // this is only a temporary id. it's negative so there's a way to identify some\n    // corrupted data if there's a redis failure between the first write of this\n    // model and the id change to its final real id\n    var id = new Date() * -1 + Math.ceil(Math.random()*1e6);\n    id_tries++;\n    self.exists(id, function (exists) {\n      if (exists && id_tries < 500) {\n        generateId();\n      } else if ( ! exists) {\n        _save(id);\n      } else {\n        Nohm.logError('Unable to find a new free id after 500 tries.');\n        callback('no free id found');\n      }\n    });\n  };\n\n  var _save = function (id) {\n    if (id) {\n      self.id = id;\n    }\n    self.valid(false, true, function (valid) {\n      if (!valid && typeof callback === 'function') {\n        if (action === 'create') {\n          self.id = null;\n        }\n        callback.call(self, 'invalid');\n      } else if (valid && action === 'create') {\n        __create.call(self, options, callback);\n      } else if (valid) {\n        __update.call(self, false, options, callback);\n      }\n    });\n  };\n\n  if (!this.id) {\n    generateId();\n  } else {\n    self.exists(this.id, function (exists) {\n      if (exists) {\n        action = 'update';\n      }\n      _save();\n    });\n  }\n};\n\nvar idGenerators = {\n  'default': function (cb) {\n    function rnd() {\n      return Math.floor(Math.random() * 1e9).toString(36);\n    }\n    cb((+ new Date()).toString(36) + rnd() + rnd());\n  },\n  'increment': function (cb) {\n    this.getClient().incr(Nohm.prefix.ids + this.modelName, function (err, newId) {\n    if (!err) {\n      cb(newId);\n    } else {\n      console.log('Nohm: Creating a new id by incrementing resulted in a client error: ' + util.inspect(err));\n      if (typeof cb === 'function') {\n        cb.call(self, err);\n      } else {\n        throw err;\n      }\n    }\n  });\n  }\n};\n\nvar __generate_id = function (cb) {\n  var generator = this.idGenerator;\n  if (typeof(generator) === 'function') {\n    generator.call(this, function (id) {\n      if (!id) {\n        Nohm.logError('A custom id generator for model '+this.modelName+' failed to provide an id.');\n      }\n      cb(id);\n    });\n  } else {\n    if (! idGenerators.hasOwnProperty(generator)) {\n      generator = 'default';\n    }\n    idGenerators[generator].call(this, cb);\n  }\n};\n\n/**\n *  Creates a new empty (!) dataset in the database and calls __update to populate it.\n * @ignore\n */\nvar __create = function __create(options, callback) {\n  var self = this;\n  __generate_id.call(this, function (newId) {\n    self.getClient().sadd(Nohm.prefix.idsets + self.modelName, newId, function (err) {\n      if (err) { Nohm.logError(err); }\n      self.__setUniqueIds(newId, function (err) {\n        if (err) { Nohm.logError(err); }\n        self.id = newId;\n        __update.call(self, true, options, callback);\n      });\n    });\n  });\n};\n\nexports.__index = function __index(p, client) {\n  var prefix;\n  client = client || this.getClient();\n  if (this.properties[p].__numericIndex) {\n    // we use scored sets for things like \"get all users older than 5\"\n    prefix = Nohm.prefix.scoredindex + this.modelName;\n    if (this.__inDB) {\n      client.zrem(prefix + ':' + p, this.id, Nohm.logError);\n    }\n    client.zadd(prefix + ':' + p, this.properties[p].value, this.id, Nohm.logError);\n  }\n  prefix = Nohm.prefix.index + this.modelName;\n  if (this.__inDB) {\n    client.srem(prefix + ':' + p + ':' + this.properties[p].__oldValue, this.id, Nohm.logError);\n  }\n  client.sadd(prefix + ':' + p + ':' + this.properties[p].value, this.id, Nohm.logError);\n};\n\n/**\n *  Update an existing dataset with the new values.\n * @ignore\n */\nvar __update = function __update(all, options, callback) {\n\n  options = h.$extend({\n    silent: false,\n    continue_on_link_error: false\n  }, options);\n\n  var p,\n    hmsetArgs = [],\n    isCreation = !this.__inDB,\n    props = this.properties,\n    self = this,\n    multi = this.getClient().multi();\n\n  hmsetArgs.push(Nohm.prefix.hash + this.modelName + ':' + this.id);\n\n  for (p in props) {\n    if (all || props[p].__updated) {\n      hmsetArgs.push(p);\n      hmsetArgs.push(props[p].value);\n    }\n  }\n\n  if (hmsetArgs.length > 1) {\n    hmsetArgs.push('__meta_version');\n    hmsetArgs.push(this.meta.version);\n    multi.hmset.apply(multi, hmsetArgs);\n  }\n\n  for (p in props) {\n    if (props.hasOwnProperty(p)) {\n      // free old uniques\n      if (props[p].unique === true && props[p].__updated) {\n        if (self.__inDB) {\n          var propLower = props[p].type === 'string' ? props[p].__oldValue.toLowerCase() : props[p].__oldValue;\n          multi.del(Nohm.prefix.unique + self.modelName + ':' + p + ':' + propLower, Nohm.logError);\n        }\n      }\n      if (props[p].index === true && (!self.__inDB || props[p].__updated)) {\n        self.__index(p, multi);\n      }\n    }\n  }\n  \n  multi.exec(function (err) {\n    if (typeof callback !== 'function' && err) {\n      Nohm.logError('Nohm: Updating an object resulted in a client error: ' + err);\n      throw err;\n    } else if (err) {\n      callback(err);\n    } else {\n\n      // we're using a serial forEach here because otherwise multiple objects \n      // may error out without notifying the callback\n      // this way once one fails it goes to error directly except if options.continue_on_link_error is set to true\n      async.forEachSeries(self.relationChanges,\n        function (item, cb) {\n          item.options.continue_on_link_error = options.continue_on_link_error;\n          item.options.silent = options.silent;\n          self['__' + item.action](item.object, item.options, function (err, child_fail, child_name) {\n            item.callback.call(self,\n                          item.action,\n                          self.modelName,\n                          item.options.name,\n                          item.object);\n            \n            if (options.continue_on_link_error || !err) {\n              cb();\n            } else if (child_fail) {\n              cb({ err: err, modelName: child_name});\n            } else {\n              cb({ err: err, modelName: item.object.modelName});\n            }\n          });\n        },\n        function (err) {\n          if (typeof callback !== 'function' && err) {\n\n            Nohm.logError('Nohm: Updating an object resulted in an error and no callback was provided: ' + err);\n\n          } else if (err) {\n\n            callback.call(self, err.err, true, err.modelName);\n\n          } else {\n            var diff;\n            if (!options.silent && self.getPublish()) {\n              // we only need the diff if we'll fire the change to pubsub\n               diff = self.propertyDiff();\n            }\n\n            self.__inDB = true;\n            for (var p in self.properties) {\n              if (self.properties.hasOwnProperty(p)) {\n                self.__resetProp(p);\n              }\n            }\n\n            if (!options.silent) {\n              if (isCreation) {\n                self.fireEvent('create');\n              } else {\n                self.fireEvent('update', diff);\n              }\n              self.fireEvent('save', diff);\n            }\n\n            callback.call(self);\n          }\n        }\n      );\n    }\n  });\n};\n\n/**\n *  Remove an objet from the database.\n *  Note: Does not destroy the js object or its properties itself!\n */\nexports.remove = function remove(options) {\n\n  var callback = h.getCallback(arguments);\n  options = options && typeof options !== 'function' ? options : {};\n\n  var self = this,\n    silent = !!options.silent;\n\n  if (!this.id) {\n    return callback('The object you are trying to delete has no id.');\n  } else if (!this.__inDB) {\n    this.load(this.id, function (err) {\n      if (err) {\n        return callback(err);\n      } else {\n        return __realDelete.call(self, silent, callback);\n      }\n    });\n  } else {\n    return __realDelete.call(self, silent, callback);\n  }\n};\n\nvar __realDelete = function __realDelete(silent, callback) {\n  var self = this;\n\n  var p,\n  id = self.id,\n  multi = self.getClient().multi();\n\n  multi.del(Nohm.prefix.hash + this.modelName + ':' + this.id);\n  multi.srem(Nohm.prefix.idsets + this.modelName, this.id);\n\n  for (p in this.properties) {\n    if (this.properties.hasOwnProperty(p)) {\n      if (this.properties[p].unique) {\n        var propLower = this.properties[p].type === 'string' ? \n          this.properties[p].__oldValue.toLowerCase() : \n          this.properties[p].__oldValue;\n        multi.del(Nohm.prefix.unique + this.modelName + ':' + p + ':' +\n                  propLower);\n      }\n      if (self.properties[p].index) {\n        multi.srem(Nohm.prefix.index + self.modelName + ':' + p + ':' +\n                   this.properties[p].__oldValue,\n                   this.id);\n      }\n      if (self.properties[p].__numericIndex) {\n        multi.zrem(Nohm.prefix.scoredindex + this.modelName + ':' + p,\n                   this.id);\n      }\n    }\n  }\n\n  this.unlinkAll(multi, function () {\n    multi.exec(function (err, values) {\n      self.id = 0;\n\n      if (!silent && !err) {\n        self.fireEvent('remove', id);\n      }\n\n      if (typeof callback === 'function') {\n        callback.call(self, err);\n      } else {\n        Nohm.logError(err);\n      }\n    });\n  });\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":9728}]],"length":9728}
